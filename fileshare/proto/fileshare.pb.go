// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/fileshare.proto

package go_jebb_fileshare

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReceiveRequest struct {
	Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveRequest) Reset()         { *m = ReceiveRequest{} }
func (m *ReceiveRequest) String() string { return proto.CompactTextString(m) }
func (*ReceiveRequest) ProtoMessage()    {}
func (*ReceiveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a75394165c713b, []int{0}
}

func (m *ReceiveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReceiveRequest.Unmarshal(m, b)
}
func (m *ReceiveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReceiveRequest.Marshal(b, m, deterministic)
}
func (m *ReceiveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveRequest.Merge(m, src)
}
func (m *ReceiveRequest) XXX_Size() int {
	return xxx_messageInfo_ReceiveRequest.Size(m)
}
func (m *ReceiveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveRequest proto.InternalMessageInfo

func (m *ReceiveRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type SendResponse struct {
	Blobs                int64    `protobuf:"varint,1,opt,name=blobs,proto3" json:"blobs,omitempty"`
	TotalSize            int64    `protobuf:"varint,2,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	TimeTaken            int64    `protobuf:"varint,3,opt,name=time_taken,json=timeTaken,proto3" json:"time_taken,omitempty"`
	Filename             string   `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	Succesful            bool     `protobuf:"varint,5,opt,name=succesful,proto3" json:"succesful,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendResponse) Reset()         { *m = SendResponse{} }
func (m *SendResponse) String() string { return proto.CompactTextString(m) }
func (*SendResponse) ProtoMessage()    {}
func (*SendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a75394165c713b, []int{1}
}

func (m *SendResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SendResponse.Unmarshal(m, b)
}
func (m *SendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SendResponse.Marshal(b, m, deterministic)
}
func (m *SendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendResponse.Merge(m, src)
}
func (m *SendResponse) XXX_Size() int {
	return xxx_messageInfo_SendResponse.Size(m)
}
func (m *SendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendResponse proto.InternalMessageInfo

func (m *SendResponse) GetBlobs() int64 {
	if m != nil {
		return m.Blobs
	}
	return 0
}

func (m *SendResponse) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *SendResponse) GetTimeTaken() int64 {
	if m != nil {
		return m.TimeTaken
	}
	return 0
}

func (m *SendResponse) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *SendResponse) GetSuccesful() bool {
	if m != nil {
		return m.Succesful
	}
	return false
}

type Blob struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Count                int64    `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	TotalBlobs           int64    `protobuf:"varint,4,opt,name=total_blobs,json=totalBlobs,proto3" json:"total_blobs,omitempty"`
	Filename             string   `protobuf:"bytes,5,opt,name=filename,proto3" json:"filename,omitempty"`
	Receiver             string   `protobuf:"bytes,6,opt,name=receiver,proto3" json:"receiver,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Blob) Reset()         { *m = Blob{} }
func (m *Blob) String() string { return proto.CompactTextString(m) }
func (*Blob) ProtoMessage()    {}
func (*Blob) Descriptor() ([]byte, []int) {
	return fileDescriptor_27a75394165c713b, []int{2}
}

func (m *Blob) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Blob.Unmarshal(m, b)
}
func (m *Blob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Blob.Marshal(b, m, deterministic)
}
func (m *Blob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Blob.Merge(m, src)
}
func (m *Blob) XXX_Size() int {
	return xxx_messageInfo_Blob.Size(m)
}
func (m *Blob) XXX_DiscardUnknown() {
	xxx_messageInfo_Blob.DiscardUnknown(m)
}

var xxx_messageInfo_Blob proto.InternalMessageInfo

func (m *Blob) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Blob) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Blob) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Blob) GetTotalBlobs() int64 {
	if m != nil {
		return m.TotalBlobs
	}
	return 0
}

func (m *Blob) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Blob) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func init() {
	proto.RegisterType((*ReceiveRequest)(nil), "go.jebb.fileshare.ReceiveRequest")
	proto.RegisterType((*SendResponse)(nil), "go.jebb.fileshare.SendResponse")
	proto.RegisterType((*Blob)(nil), "go.jebb.fileshare.Blob")
}

func init() { proto.RegisterFile("proto/fileshare.proto", fileDescriptor_27a75394165c713b) }

var fileDescriptor_27a75394165c713b = []byte{
	// 331 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x4f, 0x4f, 0xf2, 0x40,
	0x10, 0xc6, 0x59, 0x28, 0xbc, 0x30, 0x2f, 0x21, 0x3a, 0xd1, 0xd8, 0x34, 0x1a, 0xb0, 0x27, 0x0e,
	0xa6, 0x1a, 0xfd, 0x06, 0xc4, 0x98, 0x78, 0x5d, 0xbc, 0x93, 0xfe, 0x19, 0x74, 0xb5, 0x74, 0xb1,
	0xbb, 0xe5, 0xc0, 0x37, 0x31, 0xf1, 0xe6, 0x17, 0x35, 0xbb, 0x5b, 0x10, 0x15, 0x6f, 0xfb, 0xcc,
	0x33, 0xc9, 0xfc, 0x66, 0x9e, 0x85, 0xe3, 0x65, 0x29, 0xb5, 0xbc, 0x9c, 0x8b, 0x9c, 0xd4, 0x53,
	0x5c, 0x52, 0x64, 0x35, 0x1e, 0x3e, 0xca, 0xe8, 0x99, 0x92, 0x24, 0xda, 0x1a, 0xe1, 0x05, 0x0c,
	0x38, 0xa5, 0x24, 0x56, 0xc4, 0xe9, 0xb5, 0x22, 0xa5, 0x31, 0x80, 0x6e, 0xa5, 0xa8, 0x2c, 0xe2,
	0x05, 0xf9, 0x6c, 0xc4, 0xc6, 0x3d, 0xbe, 0xd5, 0xe1, 0x3b, 0x83, 0xfe, 0x94, 0x8a, 0x8c, 0x93,
	0x5a, 0xca, 0x42, 0x11, 0x1e, 0x41, 0x3b, 0xc9, 0x65, 0xa2, 0x6c, 0x67, 0x8b, 0x3b, 0x81, 0x67,
	0x00, 0x5a, 0xea, 0x38, 0x9f, 0x29, 0xb1, 0x26, 0xbf, 0x69, 0xad, 0x9e, 0xad, 0x4c, 0xc5, 0x9a,
	0xac, 0x2d, 0x16, 0x34, 0xd3, 0xf1, 0x0b, 0x15, 0x7e, 0xab, 0xb6, 0xc5, 0x82, 0x1e, 0x4c, 0xc1,
	0x00, 0x18, 0x3e, 0x0b, 0xe0, 0x39, 0x80, 0x8d, 0xc6, 0x53, 0xe8, 0xa9, 0x2a, 0x4d, 0x49, 0xcd,
	0xab, 0xdc, 0x6f, 0x8f, 0xd8, 0xb8, 0xcb, 0xbf, 0x0a, 0xe1, 0x1b, 0x03, 0x6f, 0x92, 0xcb, 0x04,
	0x07, 0xd0, 0x14, 0x59, 0x4d, 0xdf, 0x14, 0x19, 0x22, 0x78, 0x59, 0xac, 0x63, 0x8b, 0xd2, 0xe7,
	0xf6, 0x6d, 0xd0, 0x53, 0x59, 0x15, 0xba, 0x06, 0x70, 0x02, 0x87, 0xf0, 0xdf, 0xa1, 0xbb, 0xb5,
	0x3c, 0xeb, 0xb9, 0x6d, 0x26, 0x76, 0xb7, 0x5d, 0xba, 0xf6, 0x0f, 0xba, 0x00, 0xba, 0xa5, 0x3b,
	0x66, 0xe9, 0x77, 0x9c, 0xb7, 0xd1, 0xd7, 0x1f, 0x0c, 0x0e, 0xee, 0x36, 0x67, 0x9f, 0x52, 0xb9,
	0x12, 0x29, 0xe1, 0x2d, 0x78, 0xe6, 0x9c, 0x78, 0x12, 0xfd, 0x4a, 0x26, 0x32, 0xe3, 0x82, 0xe1,
	0x1e, 0x63, 0x37, 0x80, 0xb0, 0x31, 0x66, 0x78, 0x0f, 0xff, 0xea, 0x0c, 0xf1, 0x7c, 0x4f, 0xff,
	0xf7, 0x7c, 0x83, 0xbf, 0x66, 0x85, 0x8d, 0x2b, 0x96, 0x74, 0xec, 0x47, 0xb9, 0xf9, 0x0c, 0x00,
	0x00, 0xff, 0xff, 0x21, 0xd2, 0xbf, 0x5f, 0x41, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileshareServiceClient is the client API for FileshareService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileshareServiceClient interface {
	Send(ctx context.Context, opts ...grpc.CallOption) (FileshareService_SendClient, error)
	Receive(ctx context.Context, in *ReceiveRequest, opts ...grpc.CallOption) (FileshareService_ReceiveClient, error)
}

type fileshareServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileshareServiceClient(cc *grpc.ClientConn) FileshareServiceClient {
	return &fileshareServiceClient{cc}
}

func (c *fileshareServiceClient) Send(ctx context.Context, opts ...grpc.CallOption) (FileshareService_SendClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileshareService_serviceDesc.Streams[0], "/go.jebb.fileshare.FileshareService/Send", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileshareServiceSendClient{stream}
	return x, nil
}

type FileshareService_SendClient interface {
	Send(*Blob) error
	CloseAndRecv() (*SendResponse, error)
	grpc.ClientStream
}

type fileshareServiceSendClient struct {
	grpc.ClientStream
}

func (x *fileshareServiceSendClient) Send(m *Blob) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileshareServiceSendClient) CloseAndRecv() (*SendResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SendResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileshareServiceClient) Receive(ctx context.Context, in *ReceiveRequest, opts ...grpc.CallOption) (FileshareService_ReceiveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileshareService_serviceDesc.Streams[1], "/go.jebb.fileshare.FileshareService/Receive", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileshareServiceReceiveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileshareService_ReceiveClient interface {
	Recv() (*Blob, error)
	grpc.ClientStream
}

type fileshareServiceReceiveClient struct {
	grpc.ClientStream
}

func (x *fileshareServiceReceiveClient) Recv() (*Blob, error) {
	m := new(Blob)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FileshareServiceServer is the server API for FileshareService service.
type FileshareServiceServer interface {
	Send(FileshareService_SendServer) error
	Receive(*ReceiveRequest, FileshareService_ReceiveServer) error
}

func RegisterFileshareServiceServer(s *grpc.Server, srv FileshareServiceServer) {
	s.RegisterService(&_FileshareService_serviceDesc, srv)
}

func _FileshareService_Send_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileshareServiceServer).Send(&fileshareServiceSendServer{stream})
}

type FileshareService_SendServer interface {
	SendAndClose(*SendResponse) error
	Recv() (*Blob, error)
	grpc.ServerStream
}

type fileshareServiceSendServer struct {
	grpc.ServerStream
}

func (x *fileshareServiceSendServer) SendAndClose(m *SendResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileshareServiceSendServer) Recv() (*Blob, error) {
	m := new(Blob)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileshareService_Receive_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReceiveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileshareServiceServer).Receive(m, &fileshareServiceReceiveServer{stream})
}

type FileshareService_ReceiveServer interface {
	Send(*Blob) error
	grpc.ServerStream
}

type fileshareServiceReceiveServer struct {
	grpc.ServerStream
}

func (x *fileshareServiceReceiveServer) Send(m *Blob) error {
	return x.ServerStream.SendMsg(m)
}

var _FileshareService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "go.jebb.fileshare.FileshareService",
	HandlerType: (*FileshareServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Send",
			Handler:       _FileshareService_Send_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Receive",
			Handler:       _FileshareService_Receive_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/fileshare.proto",
}
